<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="2 Java内存模型, hlgao666/hlgao666">
    <meta name="description" content="一点寒芒先至，随后枪出如龙。">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>2 Java内存模型 | Allen</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/css/my.css">

    <script src="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/libs/jquery/jquery.min.js"></script>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Allen</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Allen</div>
        <div class="logo-desc">
            
            一点寒芒先至，随后枪出如龙。
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/hlgao666" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/hlgao666" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/70.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">2 Java内存模型</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/volatile/">
                                <span class="chip bg-color">volatile</span>
                            </a>
                        
                            <a href="/tags/JMM/">
                                <span class="chip bg-color">JMM</span>
                            </a>
                        
                            <a href="/tags/重排序/">
                                <span class="chip bg-color">重排序</span>
                            </a>
                        
                            <a href="/tags/happens-before/">
                                <span class="chip bg-color">happens-before</span>
                            </a>
                        
                            <a href="/tags/双重检查锁定/">
                                <span class="chip bg-color">双重检查锁定</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/多线程/" class="post-category">
                                多线程
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-06-22
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2021-06-22
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    15.5k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    54 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="Java内存模型（JMM）"><a href="#Java内存模型（JMM）" class="headerlink" title="Java内存模型（JMM）"></a>Java内存模型（JMM）</h1><h2 id="Java内存模型的基础"><a href="#Java内存模型的基础" class="headerlink" title="Java内存模型的基础"></a>Java内存模型的基础</h2><h3 id="并发编程模型的两个关键问题"><a href="#并发编程模型的两个关键问题" class="headerlink" title="并发编程模型的两个关键问题"></a>并发编程模型的两个关键问题</h3><p>在并发编程中，需要处理两个关键问题: <strong>线程之间如何通信及线程之间如何同步</strong>(这里的线程是指并发执行的活动实体)。</p>
<p>通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种: <strong>共享内存和消息传递</strong>。</p>
<p>在共享内存的并发模型里,线程之间共享程序的公共状态,<strong>通过写-读内存中的公共状态进行隐式通信</strong>。在消息传递的并发模型里,线程之间没有公共状态，线程之间必须通过发送消息来显式进行通信。</p>
<p>同步是指程序中用于控制不同线程间操作发生相对顺序的机制。<strong>在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行</strong>。在消息传递的并发模型里,由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p>
<p>Java的并发采用的是<strong>共享内存模型</strong>, Java<strong>线程之间的通信总是隐式进行</strong>,整个通信过程对程序员完全透明。</p>
<h3 id="Java内存模型的抽象结构"><a href="#Java内存模型的抽象结构" class="headerlink" title="Java内存模型的抽象结构"></a>Java内存模型的抽象结构</h3><p>Java线程之间的通信由Java内存模型(本文简称为JMM)控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系:线程之间的共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存(Local Memory)，本地内存中存储了该线程读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。Java内存模型的抽象示意如图3-1所示。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210504162220.png" alt=""></p>
<p>从图3-1来看,如果线程A与线程B之间要通信的话,必须要经历下面2个步骤。</p>
<ul>
<li>1)线程A把本地内存A中更新过的共享变量刷新到主内存中去。</li>
<li>2)线程B到主内存中去读取线程A已更新过的共享变量。</li>
</ul>
<p>下面通过示意图(见图3-2)来说明这两个步骤。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210504162355.png" alt=""></p>
<h3 id="从源代码到指合序列的重排序"><a href="#从源代码到指合序列的重排序" class="headerlink" title="从源代码到指合序列的重排序"></a>从源代码到指合序列的重排序</h3><p>在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种类型。</p>
<ul>
<li>1)编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>2)指合级并行的重排序。现代处理器采用了指今级并行技术(Instruction-Level Parallelism,ILP)来将多条指爷重叠执行。如果不存在数据依赖性,处理器可以改变语句对应机器指合的执行顺序。</li>
<li>3)内存系统的重排序。由于处理器使用缓存和读/写缓冲区,这使得加载和存储操作看上去可能是在乱序执行。</li>
</ul>
<p>从Java源代码到最终实际执行的指今序列,会分别经历下面3种重排序,如图3-3所示。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210504163031.png" alt=""></p>
<h3 id="并发编程模型的分类"><a href="#并发编程模型的分类" class="headerlink" title="并发编程模型的分类"></a>并发编程模型的分类</h3><ul>
<li>现代的处理器使用写缓冲区临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时,通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，减少对内存总线的占用。</li>
<li>虽然写缓冲区有这么多好处,<strong>但每个处理器上的写缓冲区，仅仅对它所在的处理器可见</strong>。</li>
<li>这个特性会对内存操作的执行顺序产生重要的影响: <strong>处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致</strong>!为了具体说明,请看下面的表3-1。</li>
</ul>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210504163829.png" alt=""></p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210504163920.png" alt=""></p>
<p>为了保证内存可见性,Java编译器在生成指今序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM把内存屏障指今分为4类,如表3-3所示。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210504164327.png" alt=""></p>
<ul>
<li>StoreLoad Barriers是一个“全能型”的屏障,它同时具有其他3个屏障的效果。现代的多处理器大多支持该屏障(其他类型的屏障不一定被所有处理器支持)。<strong>执行该屏障开销会很昂贵</strong>，因为当前处理器通常要<strong>把写缓冲区中的数据全部刷新到内存中</strong>(Buffer Fully Flush)。</li>
</ul>
<h3 id="happens-before简介"><a href="#happens-before简介" class="headerlink" title="happens-before简介"></a>happens-before简介</h3><p>从 JDK 5 开始，Java使用新的 JSR-133 内存模型(除非特别说明,本文针对的都是JSR-133内存模型)。JSR-133 使用 happens-before 的概念来阐述操作之间的内存可见性。在JMM中，<strong>如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系</strong>。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。</p>
<p>与程序员密切相关的happens-before规则如下。</p>
<ul>
<li>程序顺序规则:一个线程中的每个操作,happens-before于该线程中的任意后续操作。</li>
<li>监视器锁规则:对一个锁的解锁,happens-before于随后对这个锁的加锁。</li>
<li>volatile变量规则:对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li>
<li>传递性:如果A happens-before B,且B happens-before C，那么A happens-before C。</li>
</ul>
<p>注意：<strong>两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行!</strong> happens-before<strong>仅仅要求前一个操作(执行的结果)对后一个操作可见,且前一个操作按顺序排在第二个操作之前</strong>(the first is visible to and ordered before the second)。</p>
<p>happens-before的定义很微妙,后文会具体说明happens-before为什么要这么定义。<br>happens-before与JMM的关系如图3-5所示。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210504165340.png" alt=""></p>
<ul>
<li>于Java程序员来说，<strong>happens-before规则简单易懂,它避免Java程序员为了理解JMM提供的内存可见性保证而去学习复杂的重排序规则</strong>以及这些规则的具体实现方法。</li>
</ul>
<h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><ul>
<li>重排序是指编译器和处理器<strong>为了优化程序性能</strong>而对指令序列进行重新排序的一种手段。</li>
</ul>
<h3 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h3><ul>
<li>如果两个操作访问同一个变量,且这<strong>两个操作中有一个为写操作</strong>,此时这两个操作之间<strong>就存在数据依赖性</strong>。数据依赖分为下列3种类型,如表3-4所示。</li>
</ul>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210504165957.png" alt=""></p>
<ul>
<li>上面3种情况,只要重排序两个操作的执行顺序，程序的执行结果就会被改变。</li>
<li>前面提到过,编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性,编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序，<strong>即不会对存在数据依赖关系的操作进行重排序</strong>。</li>
<li>这里所说的数据依赖性仅针对单个处理器中执行的指佘序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</li>
</ul>
<h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h3><p>as-if-serial语义的意思是:不管怎么重排序(编译器和处理器为了提高并行度)，(单线程)<strong>程序的执行结果不能被改变</strong>。编译器、runtime和处理器都必须遵守as-if-serial语义。</p>
<p><strong>为了遵守as-if-serial语义,编译器和处理器不会对存在数据依赖关系的操作做重排序,因为这种重排序会改变执行结果</strong>。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210504170800.png" alt=""></p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210504170932.png" alt=""></p>
<p>如图3-6所示，A和C之间存在数据依赖关系，同时B和c之间也存在数据依赖关系。因此在最终执行的指爷序列中,C不能被重排序到A和B的前面(C排到A和B的前面,程序的结果将会被改变)。但A和B之间没有数据依赖关系,编译器和处理器可以重排序A和B之间的执行顺序。图3-7是该程序的两种执行顺序。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210504170907.png" alt=""></p>
<p>as-if-serial语义把单线程程序保护了起来,遵守as-if-serial语义的编译器、rutime和处理器共同为编写单线程程序的程序员创建了一个幻觉:单线程程序是按程序的顺序来执行的。as-if-serial语义使单线程程序员<strong>无需担心重排序会干扰他们,也无需担心内存可见性问题</strong>。</p>
<h3 id="程序顺序规则"><a href="#程序顺序规则" class="headerlink" title="程序顺序规则"></a>程序顺序规则</h3><p>根据happens-before的程序顺序规则,上面计算圆的面积的示例代码存在3个happens-before关系。</p>
<ul>
<li>1)A happens-before B。</li>
<li>2)B happens-before C。</li>
<li>3)A happens-before C。</li>
</ul>
<p>这里的第3个happens-before关系，是根据happens-before的传递性推导出来的。<br><strong>这里A happens-before B，但实际执行时B却可以排在A之前执行</strong>(看上面的重排序后的执行顺序)。</p>
<p>如果A happens-before B，JMM并不要求A一定要在B之前执行。JMM仅仅要求前一个操作(执行的结果)对后一个操作可见，且前一个操作按顺序排在第二个操作之前。这里操作A的执行结果不需要对操作B可见;而且重排序操作A和操作B后的执行结果，与操作A和操作B按happens-before顺序执行的结果一致。在这种情况下，<strong>JMM会认为这种重排序并不非法(notillegal)，JMM允许这种重排序。</strong></p>
<p>在计算机中,软件技术和硬件技术有一个共同的目标:在不改变程序执行结果的前提下，尽可能提高并行度。编译器和处理器遵从这一目标，从happens-before的定义我们可以看出，JMM同样遵从这一目标。</p>
<h3 id="重排序对多线程的影响"><a href="#重排序对多线程的影响" class="headerlink" title="重排序对多线程的影响"></a>重排序对多线程的影响</h3><ul>
<li>在单线程程序中,对存在控制依赖的操作重排序，不会改变执行结果(这也是as-if-serial语义允许对存在控制依赖的操作做重排序的原因);</li>
<li>但在多线程程序中, 对存在控制依赖的操作重排序，可能会改变程序的执行结果。</li>
</ul>
<h2 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h2><p>顺序一致性内存模型是一个理论参考模型,在设计的时候,处理器的内存模型和编程语言的内存模型都会以顺序一致性内存模型作为参照。</p>
<h3 id="数据竞争与顺序一致性"><a href="#数据竞争与顺序一致性" class="headerlink" title="数据竞争与顺序一致性"></a>数据竞争与顺序一致性</h3><p>当程序未正确同步时,就可能会存在数据竞争。Java内存模型规范对数据竞争的定义如下：<br>在一个线程中<strong>写</strong>一个变量，<br>在另一个线程<strong>读</strong>同一个变量，<br>而且写和读没有通过<strong>同步</strong>来排序。  </p>
<p>当代码中包含数据竞争时，程序的执行往往产生违反直觉的结果。如果一个多线程程序能正确同步,这个程序将是一个没有数据竞争的程序。</p>
<p>如果程序是正确同步的,程序的执行将具有顺序一致性(Sequentially Consistent)——即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同</p>
<p>这里的同步是指广义上的同步,包括对常用同步原语(synchronized、volatile和final)的正确使用。</p>
<h3 id="顺序一致性内存模型"><a href="#顺序一致性内存模型" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h3><p>顺序一致性内存模型是一个被计算机科学家理想化了的理论参考模型,它为程序员提供了极强的内存可见性保证。顺序一致性内存模型有两大特性：</p>
<ul>
<li>1)一个线程中的所有操作必须按照程序的顺序来执行。</li>
<li>2)(不管程序是否同步)所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中,每个操作都必须原子执行且立刻对所有线程可见。</li>
</ul>
<p>顺序一致性内存模型为程序员提供的视图如图3-10所示。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210504194613.png" alt=""></p>
<p>从上面的示意图可以看出,在任意时间点最多只能有一个线程可以连接到内存。当多个线程并发执行时，图中的开关装置能把所有线程的所有内存读/写操作<strong>串行化</strong>(即在顺序一致性模型中，所有操作之间具有全序关系)。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210504195708.png" alt=""></p>
<p>现在我们再假设这两个线程没有做同步，下面是这个未同步程序在顺序一致性模型中的执行示意图,如图3-12所示。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210504195935.png" alt=""></p>
<p>未同步程序在顺序一致性模型中虽然整体执行顺序是无序的,但所有线程都只能看到一个一致的整体执行顺序。以上图为例,线程A和B看到的执行顺序都是:<br>B1→A1→A2→B2→A3→B3。之所以能得到这个保证是因为<strong>顺序一致性内存模型中的每个操作必须立即对任意线程可见</strong>。</p>
<p>但是,<strong>在JMM中就没有这个保证</strong>。未同步程序在JMM中不但整体的执行顺序是无序的,而且<strong>所有线程看到的操作执行顺序也可能不一致</strong>。比如,在当前线程把写过的数据缓存在本地内存中,在没有刷新到主内存之前,这个写操作仅对当前线程可见;从其他线程的角度来观察，会认为这个写操作根本没有被当前线程执行。只有当前线程把本地内存中写过的数据刷新到主内存之后,这个写操作才能对其他线程可见。在这种情况下，当前线程和其他线程看到的操作执行顺序将不一致。</p>
<h3 id="同步程序的顺序一致性效果"><a href="#同步程序的顺序一致性效果" class="headerlink" title="同步程序的顺序一致性效果"></a>同步程序的顺序一致性效果</h3><p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210504201758.png" alt=""></p>
<p>顺序一致性模型中,<strong>所有操作完全按程序的顺序串行执行</strong>。而在JMM中,临界区内的代码可以重排序(但JMM不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义)。JMM会在退出临界区和进入临界区这两个关键时间点做一些特别处理,使得线程在这两个时间点具有与顺序一致性模型相同的内存视图(具体细节后文会说明)。虽然线程A在临界区内做了重排序,但由于监视器互斥执行的特性，这里的线程B根本无法“观察”到线程A在临界区内的重排序。这种<strong>重排序既提高了执行效率,又没有改变程序的执行结果</strong>。</p>
<h3 id="未同步程序的执行特性"><a href="#未同步程序的执行特性" class="headerlink" title="未同步程序的执行特性"></a>未同步程序的执行特性</h3><p>对于未同步或未正确同步的多线程程序，JMM只提供最小安全性: 线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值(0，Null, False)，JMM保证线程读操作读取到的值不会无中生有(Out Of Thin Air)的冒出来。为了实现最小安全性,JVM在堆上分配对象时，首先会对内存空间进行清雩,然后才会在上面分配对象(JVM内部会同步这两个操作)。因此,在已清雾的内存空间(Pre-zeroed Memory)分配对象时，域的默认初始化已经完成了。</p>
<p>JMM不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致。因为如果想要保证执行结果一致，JMM需要禁止大量的处理器和编译器的优化,这对程序的执行性能会产生很大的影响。而且未同步程序在顺序一致性模型中执行时，整体是无序的,其执行结果往往无法预知。而且，保证未同步程序在这两个模型中的执行结果一致没什么意义。</p>
<p>未同步程序在JMM中的执行时,整体上是无序的，其执行结果无法预知。未同步程序在两个模型中的执行特性有如下几个差异。</p>
<ul>
<li>1)顺序一致性模型保证单线程内的操作会按程序的顺序执行，而<strong>JMM不保证单线程内的操作会按程序的顺序执行</strong>(比如上面正确同步的多线程程序在临界区内的重排序)。这一点前面已经讲过了,这里就不再赘述。</li>
<li>2)顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。这一点前面也已经讲过,这里就不再赘述。</li>
<li>3)JMM不保证对64位的long型和double型变量的写操作具有原子性,而顺序一致性模型保证对所有的内存读/写操作都具有原子性。</li>
</ul>
<p>第3个差异与处理器总线的工作机制密切相关。在计算机中, 数据通过总线在处理器和内存之间传递。每次处理器和内存之间的数据传递都是通过一系列步骤来完成的,这一系列步<br>骤称之为<strong>总线事务</strong>(Bus Transaction)。</p>
<p>总线事务包括<strong>读事务</strong>(Read Transaction)和<strong>写事务</strong>(WriteTransaction)。读事务从内存传送数据到处理器,写事务从处理器传送数据到内存,每个事务会读/写内存中一个或多个物理上连续的字。这里的关键是,<strong>总线会同步试图并发使用总线的事务</strong>。在一个处理器执行总线事务期间，总线会禁止其他的处理器和IO设备执行内存的读/写。通过一个示意图来说明总线的工作机制,如图3-14所示。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210504202929.png" alt=""></p>
<p>由图可知,假设处理器A, B和c同时向总线发起总线事务,这时<strong>总线仲裁</strong>(Bus Arbitration)会对竞争做出裁决，这里假设总线在仲裁后判定处理器A在竞争中获胜(总线仲裁会确保所有处理器都能公平的访问内存)。此时处理器A继续它的总线事务,而其他三个处理器则要等待处理器A的总线事务完成后才能再次执行内存访问。假设在处理器A执行总线事务期间(不管这个总线事务是读事务还是写事务),处理器D向总线发起了总线事务,此时处理器D的请求会被总线禁止。</p>
<p>总线的这些工作机制可以把所有处理器对内存的访问以<strong>串行化</strong>的方式来执行。在任意时间点，最多只能有一个处理器可以访问内存。这个特性确保了单个总线事务之中的内存读/写操作具有原子性。</p>
<p>当单个内存操作不具有原子性时，可能会产生意想不到后果。请看示意图，如图3-15所示。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210504203407.png" alt=""></p>
<p>如上图所示，假设处理器A写一个long型变量,同时处理器B要读这个long型变量。处理器A中64位的写操作被拆分为两个32位的写操作,且这两个32位的写操作被分配到不同的写事务中执行。同时，处理器B中64位的读操作被分配到单个的读事务中执行。当处理器A和B按上图的时序来执行时,处理器B将看到仅仅被处理器A“写了一半”的无效值。</p>
<p>注意，在JSR-133之前的旧内存模型中，一个64位long/double型变量的<strong>读/写</strong>操作可以被拆分为两个32位的<strong>读/写</strong>操作来执行。MJSR-133内存模型开始(即从JDK5开始),仅仅只允许把一个64位long/double型变量的<strong>写操作</strong>拆分为两个32位的<strong>写操作</strong>来执行，任意的读操作在JSR-133中都必须具有原子性(即<strong>任意读操作必须要在单个读事务中执行</strong>)。</p>
<h2 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h2><p>当声明共享变量为volatile后，对这个变量的读/写将会很特别。</p>
<h3 id="volatile的特性"><a href="#volatile的特性" class="headerlink" title="volatile的特性"></a>volatile的特性</h3><p>理解volatile特性的一个好方法是把对volatile变量的单个读/写, 看成是<strong>使用同一个锁对这些单个读/写操作做了同步</strong>。前者作用于变量，后者作用于方法本身。</p>
<p>简而言之,volatile变量自身具有下列特性。</p>
<ul>
<li>可见性：对一个volatile变量的读，总是能看到(任意线程)对这个volatile变量最后的写入。</li>
<li>原子性：对任意单个volatile变量的读/写具有原子性,但类似于volatile++这种复合操作不具有原子性。</li>
</ul>
<h3 id="volatile写-读建立的happens-before关系"><a href="#volatile写-读建立的happens-before关系" class="headerlink" title="volatile写-读建立的happens-before关系"></a>volatile写-读建立的happens-before关系</h3><p>从JSR-133开始(即从JDK5开始)，volatile变量的写-读可以实现<strong>线程之间的通信</strong>。</p>
<p>从内存语义的角度来说， volatile的写-读与锁的释放-获取有相同的内存效果:</p>
<ul>
<li>volatile<strong>写</strong>和<strong>锁的释放</strong>有相同的内存语义; </li>
<li>volatile<strong>读</strong>与<strong>锁的获取</strong>有相同的内存语义。</li>
</ul>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210504205705.png" alt=""></p>
<p>假设线程A执行writer()方法之后,线程B执行reader)方法。根据happens-before规则,这个过程建立的happens-before关系可以分为3类:</p>
<ul>
<li>1)根据程序次序规则,1 happens-before 2;3 happens-before 4。</li>
<li>2)根据volatile规则，2 happens-before 3。</li>
<li>3)根据happens-before的传递性规则,1 happens-before 4。</li>
</ul>
<p>上述happens-before关系的图形化表现形式如下。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210504205750.png" alt=""></p>
<p>在上图中，每一个箭头链接的两个节点,代表了一个happens-before关系。黑色箭头表示程序顺序规则;橙色箭头表示volatile规则;蓝色箭头表示组合这些规则后提供的happens-before保证。</p>
<p>这里A线程写一个volatile变量后,B线程读同一个volatile变量。A线程在写volatile变量之前<strong>所有可见的共享变量</strong>,在B线程<strong>读同一个volatile变量后,将立即变得对B线程可见</strong>。</p>
<h3 id="volatile写-读的内存语义"><a href="#volatile写-读的内存语义" class="headerlink" title="volatile写-读的内存语义"></a>volatile写-读的内存语义</h3><p>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。</p>
<p>以上面示例程序VolatileExample为例,假设线程A首先执行writer()方法,随后线程B执行reader()方法,初始时两个线程的本地内存中的flag和a都是初始状态。图3-17是线程A执行volatile写后，共享变量的状态示意图。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210504210906.png" alt=""></p>
<p>volatile读的内存语义如下：<br>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</p>
<p>图3-18为线程B读同一个volatile变量后,共享变量的状态示意图。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210504211007.png" alt=""></p>
<p>在线程B读一个volatile变量后，写线程A在写这个volatile变量之前所有可见的共享变量的值都将立即变得对读线程B可见。</p>
<p>下面对volatile写和volatile读的内存语义做个总结：</p>
<ul>
<li>线程A写一个volatile变量,实质上是线程A向接下来将要读这个volatile变量的某个线程发出了(其对共享变量所做修改的)消息。</li>
<li>线程B读一个volatile变量,实质上是线程B接收了之前某个线程发出的(在写这个volatile变量之前对共享变量所做修改的)消息。</li>
<li>线程A写一个volatile变量,随后线程B读这个volatile变量,这个过程实质上是线程A通过主内存向线程B发送消息。</li>
</ul>
<h3 id="volatile内存语义的实现"><a href="#volatile内存语义的实现" class="headerlink" title="volatile内存语义的实现"></a>volatile内存语义的实现</h3><p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210504211720.png" alt=""></p>
<ul>
<li>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</li>
<li>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</li>
<li>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</li>
</ul>
<p>为了实现volatile的内存语义,编译器在生成字节码时，会在指合序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能。为此, JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略。</p>
<ul>
<li>在每个volatile写操作的前面插入一个StoreStore屏障。</li>
<li>在每个volatile写操作的后面插入一个storeLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障。</li>
</ul>
<p>下面是保守策略下，volatile写插入内存屏障后生成的指今序列示意图,如图3-19所示。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210504212202.png" alt=""></p>
<p>图3-19中的StoreStore屏障可以保证在volatile写之前,其前面的所有普通写操作已经对任意处理器可见了。这是因为StoreStore屏障将保障上面所有的普通写在volatile写之前刷新到主内存。</p>
<ul>
<li>这里比较有意思的是, volatile写后面的StoreLoad屏障。此屏障的作用是避免volatile写与后面可能有的volatile读/写操作重排序。因为编译器常常无法准确判断在一个volatile写的后面是否需要插入一个StoreLoad屏障(比如,一个volatile写之后方法立即return)。为了保证能正确实现volatile的内存语义,JMM在采取了保守策略:在每个volatile写的后面,或者在每个volatile读的前面插入一个StoreLoad屏障。</li>
<li>从整体执行效率的角度考虑，JMM最终选择了在每个<br>volatile写的后面插入一个StoreLoad屏障。因为volatile写-读内存语义的常见使用模式是:一个写线程写volatile变量,多个读线程读同一个volatile变量。当读线程的数量大大超过写线程时,选择在volatile写之后插入StoreLoad屏障将带来可观的执行效率的提升。从这里可以看到JMM在实现上的一个特点: <strong>首先确保正确性,然后再去追求执行效率</strong>。</li>
</ul>
<h3 id="JSR-133为什么要增强volatile的内存语义"><a href="#JSR-133为什么要增强volatile的内存语义" class="headerlink" title="JSR-133为什么要增强volatile的内存语义"></a>JSR-133为什么要增强volatile的内存语义</h3><p>在JSR-133之前的旧Java内存模型中,虽然不允许volatile变量之间重排序,但旧的Java内存模型允许volatile变量与普通变量重排序。</p>
<p>在旧的内存模型中, volatile的写-读没有锁的释放-获取所具有的内存语义。<strong>为了提供一种比锁更轻量级的线程之间通信的机制</strong>, JSR-133专家组决定增强volatile的内存语义:严格限制编译器和处理器对volatile变量与普通变量的重排序,确保volatile的写-读和锁的释放-获取具有相同的内存语义。</p>
<p>从编译器重排序规则和处理器内存屏障插入策略来看,只要volatile变量与普通变量之间的重排序可能会破坏volatile的内存语义,这种重排序就会被编译器<strong>重排序规则</strong>和处理器<strong>内存屏障插入策略</strong>禁止。</p>
<p>由于<strong>volatile</strong>仅仅保证对<strong>单个volatile变量的读/写具有原子性</strong>,而<strong>锁的互斥执行</strong>的特性可以确保<strong>对整个临界区代码的执行具有原子性</strong>。在功能上，锁比volatile更强大;在可伸缩性和执行性能上，,volatile更有优势。</p>
<h2 id="锁的内存语义"><a href="#锁的内存语义" class="headerlink" title="锁的内存语义"></a>锁的内存语义</h2><h3 id="锁的释放-获取建立的happens-before关系"><a href="#锁的释放-获取建立的happens-before关系" class="headerlink" title="锁的释放-获取建立的happens-before关系"></a>锁的释放-获取建立的happens-before关系</h3><p>锁是Java并发编程中最重要的同步机制。锁除了让临界区互斥执行外,还可以让释放锁的线程向获取同一个锁的线程发送消息。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210504214712.png" alt=""></p>
<p>上述happens-before关系的图形化表现形式如图3-24所示。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210504214748.png" alt=""></p>
<p>图3-24表示在线程A释放了锁之后，随后线程B获取同一个锁。在上图中，2happens-before5。因此,线程A在释放锁之前所有可见的共享变量,在线程B获取同一个锁之后，将立刻变得对B线程可见。</p>
<h3 id="锁的释放和获取的内存语义"><a href="#锁的释放和获取的内存语义" class="headerlink" title="锁的释放和获取的内存语义"></a>锁的释放和获取的内存语义</h3><p>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。见图3-18。</p>
<h3 id="锁内存语义的实现"><a href="#锁内存语义的实现" class="headerlink" title="锁内存语义的实现"></a>锁内存语义的实现</h3><p>intel的手册对1ock前缀的说明如下：</p>
<ul>
<li>1)确保对内存的读-改-写操作原子执行。在Pentium及Pentium之前的处理器中,带有1ock前缀的指今在执行期间会锁住总线，使得其他处理器暂时无法通过总线访问内存。很显然,这会带来昂贵的开销。从Pentium4、Intel Xeon及P6处理器开始,Intel使用缓存锁定(Cache Locking)来保证指爷执行的原子性。缓存锁定将大大降低lock前缀指合的执行开销。</li>
<li>2)禁止该指今，与之前和之后的读和写指合重排序。</li>
<li>3)把写缓冲区中的所有数据刷新到内存中。</li>
</ul>
<p>上面的第2点和第3点所具有的内存屏障效果,足以同时实现volatile读和volatile写的内存语义。</p>
<p>经过上面的分析，现在我们终于能明白为什么JDK文档说<strong>CAS同时具有volatile读和volatile写的内存语义了</strong>。</p>
<p>现在对公平锁和非公平锁的内存语义做个总结。</p>
<ul>
<li>公平锁和非公平锁<strong>释放</strong>时，<strong>最后都要写一个volatile变量state</strong>。</li>
<li>公平锁<strong>获取</strong>时，<strong>首先会去读volatile变量</strong>。</li>
<li>非公平锁获取时，首先会用CAS更新volatile变量, 这个操作同时具有volatile读和volatile写的内存语义。</li>
</ul>
<p>从对ReentrantLock的分析可以看出，锁释放-获取的内存语义的实现至少有下面两种方式。</p>
<ul>
<li>1)利用volatile变量的写-读所具有的内存语义。</li>
<li>2)利用CAS所附带的volatile读和volatile写的内存语义。</li>
</ul>
<h3 id="concurrent包的实现"><a href="#concurrent包的实现" class="headerlink" title="concurrent包的实现"></a>concurrent包的实现</h3><p>由于Java的CAS同时具有volatile读和volatile写的内存语义，因此Java线程之间的通信现在有了下面4种方式。</p>
<ul>
<li>1)A线程写volatile变量，随后B线程读这个volatile变量。</li>
<li>2)A线程写volatile变量,随后B线程用CAs更新这个volatile变量。</li>
<li>3)A线程用CAS更新一个volatile变量,随后B线程用CAS更新这个volatile变量。</li>
<li>4)A线程用CAS更新一个volatile变量,随后B线程读这个volatile变量。</li>
</ul>
<p>Java的CAS会使用现代处理器上提供的高效机器级别的原子指今,这些原子指今以原子方式对内存执行读-改-写操作,这是在多处理器中实现同步的<strong>关键</strong>。同时, volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起,就形成了整个concurrent包得以实现的<strong>基石</strong>。</p>
<p>如果我们仔细分析concurrent包的源代码实现,会发现一个通用化的实现模式。</p>
<ul>
<li>首先,声明共享变量为volatile。</li>
<li>然后,使用CAS的原子条件更新来实现线程之间的同步。</li>
<li>同时,配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。</li>
</ul>
<p>AQS，非阻塞数据结构和原子变量类(java.util.concurrent.atomic包中的类)，这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。从整体来看,concuurrent包的实现示意图如3-28所示。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210505150102.png" alt=""></p>
<h2 id="final域的内存语义"><a href="#final域的内存语义" class="headerlink" title="final域的内存语义"></a>final域的内存语义</h2><h3 id="final域（属性）的重排序规则"><a href="#final域（属性）的重排序规则" class="headerlink" title="final域（属性）的重排序规则"></a>final域（属性）的重排序规则</h3><p>对于final域，编译器和处理器要遵守两个重排序规则。</p>
<ul>
<li>1)在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量,这两个操作之间不能重排序。</li>
<li>2)初次读一个包含final域的对象的引用，与随后初次读这个final域,这两个操作之间不能重排序。</li>
</ul>
<p>下面通过一些示例性的代码来分别说明这两个规则。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210505151651.png" alt=""></p>
<p>这里假设一个线程A执行writer()方法,随后另一个线程B执行reader()方法。下面我们通过这两个线程的交互来说明这两个规则。</p>
<h3 id="写final域的重排序规则"><a href="#写final域的重排序规则" class="headerlink" title="写final域的重排序规则"></a>写final域的重排序规则</h3><p>写final域的重排序规则<strong>禁止把final域的写重排序到构造函数之外</strong>。这个规则的实现包含下面2个方面。</p>
<ul>
<li>1)JMM禁止编译器把final域的写重排序到构造函数之外。</li>
<li>2)编译器会在final域的写之后,构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外。</li>
</ul>
<p>假设线程B读对象引用与读对象的成员域之间没有重排序，图3-29是一种可能的执行时序。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210505151806.png" alt=""></p>
<p>在图3-29中，写普通域的操作被编译器重排序到了构造函数之外，读线程B错误地读取了普通变量i初始化之前的值。而写final域的操作，被写final域的重排序规则“限定”在了构造函数之内，读线程B正确地读取了final变量初始化之后的值。</p>
<p>写final域的重排序规则可以确保:在对象引用为任意线程可见之前,对象的final域已经被正确初始化过了,而普通域不具有这个保障。以上图为例,在读线程B看到”对象引用obj时，很可能obj对象还没有构造完成(对普通域i的写操作被重排序到构造函数外,此时初始值1还没有写入普通域i)。</p>
<h3 id="读final域的重排序规则"><a href="#读final域的重排序规则" class="headerlink" title="读final域的重排序规则"></a>读final域的重排序规则</h3><p>读final域的重排序规则是, <strong>在一个线程中, 初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作</strong>(注意,这个规则仅仅针对处理器)。编译器会在读final域操作的前面插入一个LoadLoad屏障。</p>
<p>初次读对象引用与初次读该对象包含的final域,这两个操作之间存在间接依赖关系。由于编译器遵守间接依赖关系,因此编译器不会重排序这两个操作。大多数处理器也会遵守间接依赖,也不会重排序这两个操作。但<strong>有少数处理器允许对存在间接依赖关系的操作做重排序</strong>(比如alpla处理器)，这个规则就是专门用来针对这种处理器的。</p>
<p>reader()方法包含3个操作。</p>
<ul>
<li>初次读引用变量obj。</li>
<li>初次读引用变量obj指向对象的普通域j。</li>
<li>初次读引用变量obj指向对象的final域i。</li>
</ul>
<p>现在假设写线程A没有发生任何重排序，同时程序在不遵守间接依赖的处理器上执行,图3-30所示是一种可能的执行时序。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210505152930.png" alt=""></p>
<p>在图3-30中，读对象的普通域的操作被处理器重排序到读对象引用之前。读普通域时，该域还没有被写线程A写人，这是一个<strong>错误</strong>的读取操作。而读final域的重排序规则会把读对象final域的操作“限定”在读对象引用之后，此时该final域已经被A线程初始化过了,这是一个<strong>正确</strong>的读取操作。</p>
<p>读final域的重排序规则可以确保:在读一个对象的final域之前,一定会先读包含这个final域的对象的引用。在这个示例程序中，如果该引用不为mull，那么引用对象的final域一定已经被A线程初始化过了。</p>
<h3 id="final域为引用类型"><a href="#final域为引用类型" class="headerlink" title="final域为引用类型"></a>final域为引用类型</h3><p>上面我们看到的final域是基础数据类型,如果final域是引用类型,将会有什么效果?请看下列示例代码。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210505153905.png" alt=""></p>
<p>本例final域为一个引用类型，它引用一个int型的数组对象。对于引用类型,写final域的重排序规则对编译器和处理器增加了如下约束: <strong>在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量,这两个操作之间不能重排序</strong>。</p>
<p>对上面的示例程序,假设首先线程A执行writerOne()方法,执行完后线程B执行<br>writerTwo()方法,执行完后线程C执行reader()方法。图3-31是一种可能的线程执行时序。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210505154043.png" alt=""></p>
<p>在图3-31中,1是对final域的写入，2是对这个final域引用的对象的成员域的写入，3是把被构造的对象的引用赋值给某个引用变量。这里除了前面提到的<strong>1不能和3重排序外, 2和3也不能重排序。</strong></p>
<p><strong>JMM可以确保读线程C至少能看到写线程A在构造函数中对final引用对象的成员域的写入。即c至少能看到数组下标0的值为1。而写线程B对数组元素的写入，读线程C可能看得到,也可能看不到</strong>。JMM不保证线程B的写入对读线程C可见,因为写线程B和读线程C之间存在数据竞争，此时的执行结果不可预知。</p>
<p>如果想要确保读线程C看到写线程B对数组元素的写入，写线程B和读线程c之间需要使用同步原语(lock或volatile)来确保内存可见性。</p>
<h3 id="为什么final引用不能从构造豳数内“逸出”"><a href="#为什么final引用不能从构造豳数内“逸出”" class="headerlink" title="为什么final引用不能从构造豳数内“逸出”"></a>为什么final引用不能从构造豳数内“逸出”</h3><p>前面我们提到过，写final域的重排序规则可以确保:在引用变量为任意线程可见之前，该引用变量指向的对象的final域已经在构造图数中被<strong>正确初始化</strong>过了。其实,要得到这个效果，还需要一个保证:在构造函数内部,<strong>不能让这个被构造对象的引用为其他线程所见</strong>,也就是对象引用不能在构造函数中“逸出”。为了说明问题,让我们来看下面的示例代码。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210505154900.png" alt=""></p>
<p>假设一个线程A执行writer()方法.另一个线程B执行reader()方法。这里的操作2<strong>使得对象还未完成构造前就为线程B可见</strong>。即使这里的操作2是构造函数的最后一步,且在程序中操作2排在操作1后面,执行read()方法的线程仍然可能无法看到final域被初始化后的值,因为这里的操作1和操作2之间可能被重排序。实际的执行时序可能如图3-32所示。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210505155123.png" alt=""></p>
<p>从图3-32可以看出: 在构造函数返回前，被构造对象的引用不能为其他线程所见,因为此时的final域可能还没有被初始化。<strong>在构造函数返回后，任意线程都将保证能看到final域正确初始化之后的值</strong>。</p>
<h3 id="JSR-133为什么要增强final的语义"><a href="#JSR-133为什么要增强final的语义" class="headerlink" title="JSR-133为什么要增强final的语义"></a>JSR-133为什么要增强final的语义</h3><p>在旧的Java内存模型中,一个最严重的缺陷就是线程可能看到final域的值会改变。比如，一个线程当前看到一个整型final域的值为0(<strong>还未初始化之前的默认值</strong>)，过一段时间之后这个线程再去读这个final域的值时，却发现值变为1(<strong>被某个线程初始化之后的值)</strong>。最常见的例子就是在旧的Java内存模型中，String的值可能会改变。</p>
<p>为了修补这个漏洞，JSR-133专家组增强了final的语义。通过为final域增加写和读重排序规则,可以为Java程序员提供初始化安全保证: <strong>只要对象是正确构造的</strong>(被构造对象的引用在构造函数中没有“逸出”)，那么<strong>不需要使用同步</strong>(指lock和volatile的使用)就可以保证任意线程都能看到这个final域在构造函数中被<strong>正确初始化</strong>之后的值。</p>
<h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>happens-before是JMM最核心的概念。对应Java程序员来说，理解happens-before是理解JMM的关键。</p>
<h3 id="JMM的设计"><a href="#JMM的设计" class="headerlink" title="JMM的设计"></a>JMM的设计</h3><p>首先,让我们来看JMM的设计意图。MJMM设计者的角度,在设计JMM时，需要考虑两个关键因素。</p>
<ul>
<li>程序员对内存模型的使用。程序员希望内存模型易于理解、易于编程。程序员希望基于一个强内存模型来编写代码。</li>
<li>编译器和处理器对内存模型的实现。编译器和处理器希望内存模型对它们的束缚越少越好,这样它们就可以做尽可能多的优化来提高性能。编译器和处理器希望实现一个弱内存模型。</li>
</ul>
<p>由于这两个因素互相矛盾,所以JSR-133专家组在设计JMM时的核心目标就是找到一个好的平衡点:一方面,要为程序员提供足够强的内存可见性保证;另一方面，对编译器和处理器的限制要尽可能地放松。下面让我们来看JSR-133是如何实现这一目标的。</p>
<p>JMM把happens-before要求禁止的重排序分为了下面两类：</p>
<ul>
<li>会改变程序执行结果的重排序。</li>
<li>不会改变程序执行结果的重排序。</li>
</ul>
<p>JMM对这两种不同性质的重排序，采取了不同的策略,如下：</p>
<ul>
<li>对于会改变程序执行结果的重排序，JMM要求编译器和处理器必须禁止这种重排序。</li>
<li>对于不会改变程序执行结果的重排序，JMM对编译器和处理器不做要求(JMM允许这种重排序)。</li>
</ul>
<p>图3-33是JMM的设计示意图。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210505155719.png" alt=""></p>
<h2 id="happens-before的定义"><a href="#happens-before的定义" class="headerlink" title="happens-before的定义"></a>happens-before的定义</h2><p>《JSR-133:Java Memory Model and Thread Specification》对happens-before关系的定义如下。</p>
<ul>
<li>1)如果一个操作happens-before另一个操作，那么<strong>第一个操作的执行结果将对第二个操作可见,而且第一个操作的执行顺序排在第二个操作之前</strong>。</li>
<li>2)两个操作之间存在happens-before关系,并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果,与按happens-before关系来执行的结果一致，那么这种重排序并不非法(也就是说，JMM允许这种重排序)。</li>
</ul>
<ul>
<li>上面的1)是JMM对程序员的承诺。从程序员的角度来说，可以这样理解happens-before关系:如果A happens-before B，那么Java内存模型将向程序员保证——A操作的结果将对B可见,且A的执行顺序排在B之前。注意,这只是Java内存模型向程序员做出的保证!</li>
<li>上面的2)是JMM对编译器和处理器重排序的约束原则。正如前面所言，JMM其实是在遵循一个基本原则:只要不改变程序的执行结果(指的是单线程程序和正确同步的多线程程序)，编译器和处理器怎么优化都行。</li>
<li>JMM这么做的原因是:程序员对于这两个操作是否真的被重排序并不关心,程序员关心的是程序执行时的语义不能被改变(即执行结果不能被改变)。因此, <strong>happens-before关系本质上和as-if-serial语义是一回事</strong>。</li>
</ul>
<ul>
<li>“as-if-serial语义保证单线程内程序的执行结果不被改变, happens-before关系保证正确同步的多线程程序的执行结果不被改变。</li>
<li>“as-if-serial语义给编写单线程程序的程序员创造了一个幻境:单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境:正确同步的多线程程序是按happens-before指定的顺序来执行的。</li>
<li>as-if-serial语义和happens-before这么做的目的，<strong>都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度</strong>。</li>
</ul>
<h3 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h3><p>《JSR-133:Java Memory Model and Thread Specification》定义了如下happens-before规则。</p>
<ul>
<li>1)程序顺序规则:一个线程中的每个操作， happens-before于该线程中的任意后续操作。</li>
<li>2)监视器锁规则:对一个锁的解锁,happens-before于随后对这个锁的加锁。</li>
<li>3)volatile变量规则:对一个volatile域的写,happens-before于任意后续对这个volatile域的读。</li>
<li>4)传递性:如果A happens-before B，且B happens-before C，那么A happens-before C。</li>
<li>5)start()规则:如果线程A执行操作ThreadB.start()(启动线程B)，那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。</li>
<li>6)join()规则:如果线程A执行操作ThreadB,join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li>
<li>7)线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。</li>
<li>8)对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</li>
</ul>
<p>下面我们来看start()规则。假设线程A在执行的过程中,通过执行ThreadB.start()来后动线程B;同时，假设线程A在执行ThreadB.start()之前修改了一些共享变量,线程B在开始执行后会读这些共享变量。图3-35是该程序对应的happens-before关系图。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210505192030.png" alt=""></p>
<p>在图3-35中，1 happens-before 2由程序顺序规则产生。2 happens-before 4由start()规则产生。根据传递性,将有1 happens-before 4。这意味着,线程A在执行ThreadB.start()之前对共享变量所做的修改,接下来在线程B开始执行后都将确保对线程B可见。</p>
<p>下面我们来看join()规则。假设线程A在执行的过程中，通过执行ThreadB.join()来等待线程B终止;同时,假设线程B在终止之前修改了一些共享变量,线程A从ThreadB.join()返回后会读这些共享变量。图3-36是该程序对应的happens-before关系图。</p>
<p>join()操作：若线程A调用ThreadB.join()方法，则线程A将会被挂起，直到线程B执行完后，线程A才接着执行。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210505192157.png" alt=""></p>
<p>在图3-36中，2 happens-before 4由join)规则产生; 4 happens-before 5由程序顺序规则产生。根据传递性规则,将有2 happens-before 5。这意味着,线程A执行操作ThreadB.join()并成功返回后,线程B中的任意操作都将对线程A可见。</p>
<h2 id="双重检查锁定与延迟初始化"><a href="#双重检查锁定与延迟初始化" class="headerlink" title="双重检查锁定与延迟初始化"></a>双重检查锁定与延迟初始化</h2><p>在Java多线程程序中,有时候需要采用<strong>延迟初始化来降低初始化类和创建对象的开销</strong>。<strong>双重检查锁定</strong>是常见的延迟初始化技术，但它<strong>是一个错误的用法</strong>。本文将分析双重检查锁定的错误根源，以及两种线程安全的延迟初始化方案。</p>
<h3 id="双重检查锁定的由来"><a href="#双重检查锁定的由来" class="headerlink" title="双重检查锁定的由来"></a>双重检查锁定的由来</h3><p>在Java程序中,<strong>有时候可能需要推迟一些高开销的对象初始化操作,并且只有在使用这些对象时才进行初始化</strong>。此时，程序员可能会采用延迟初始化。但要正确实现线程安全的延迟初始化需要一些技巧，否则很容易出现问题。比如，下面是<strong>非线程安全</strong>的延迟初始化对象的示例代码。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210505193857.png" alt=""></p>
<p>在UnsafeLazylnitialization类中,假设A线程执行代码1的同时,B线程执行代码2。此时,<strong>线程A可能会看到instance引用的对象还没有完成初始化</strong>。</p>
<p>对于UnsafeLazylnitialization类，我们可以对getInstance()方法做同步处理来实现线程安全的延迟初始化。示例代码如下。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210505194022.png" alt="实例化方法加了 synchronized"></p>
<p>双重检查锁定(Double-Checked Locking)。<strong>人们想通过双重检查锁定来降低同步的开销</strong>。下面是使用双重检查锁定来实现延迟初始化的示例代码。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210505194150.png" alt=""></p>
<p>如上面代码所示,如果第一次检查instance不为null，那么就不需要执行下面的加锁和初始化操作。因此,可以大幅降低synclronized带来的性能开销。上面代码表面上看起来,<strong>似乎两全其美。</strong></p>
<p>双重检查锁定看起来似乎很完美，<strong>但这是一个错误的优化</strong>!在线程执行到第4行，代码读取到instance不为null时，instance引用的对象有可能还没有完成初始化。</p>
<h3 id="问题的根源"><a href="#问题的根源" class="headerlink" title="问题的根源"></a>问题的根源</h3><p>前面的双重检查锁定示例代码的第7行(instance=new Singleton();)创建了一个对象。这一行代码可以分解为如下的3行伪代码。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210505194447.png" alt=""></p>
<p>注意：2和3可能重排序</p>
<p>Java语言规范7仅表明：线程在执行Java程序时必须要遵守intra-thread semantics。intra-tlhread semantics保证重排序不会改变<strong>单线程</strong>内的程序执行结果。换句话说,intra-tlhread semantics允许那些在单线程内，不会改变单线程程序执行结果的重排序。上面3行伪代码的2和3之间虽然被重排序了，但这个重排序并不会影响intra-thread semantics。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210505194756.png" alt=""></p>
<p>但换做多线程访问时，可能出现线程B访问的实例对象还没有被初始化。</p>
<p>注意：<strong>只要为 instance分配了内存空间，访问结果就不为null</strong></p>
<p>在知晓了问题发生的根源之后，我们可以想出两个办法来实现线程安全的延迟初始化。</p>
<ul>
<li>1)不允许2和3重排序。</li>
<li>2)允许2和3重排序,但不允许其他线程“看到”这个重排序。</li>
</ul>
<h3 id="基于volatile的解决方案"><a href="#基于volatile的解决方案" class="headerlink" title="基于volatile的解决方案"></a>基于volatile的解决方案</h3><p>对于前面的基于双重检查锁定来实现延迟初始化的方案(指DoubleCheckedLocking示例代码)，只需要做一点小的修改(把instance声明为volatile型),就可以实现线程安全的延迟初始化。请看下面的示例代码。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210505200131.png" alt=""></p>
<p>当声明对象的引用为volatile后，3行伪代码中的2和3之间的重排序,在多线程环境中将会被禁止。</p>
<h3 id="基于类初始化的解决方案"><a href="#基于类初始化的解决方案" class="headerlink" title="基于类初始化的解决方案"></a>基于类初始化的解决方案</h3><p>JVM在类的初始化阶段(即在Class被加载后,且被线程使用之前)，会执行类的初始化。在执行类的初始化期间,JVM会去获取一个锁。<strong>这个锁可以同步多个线程对同一个类的初始化</strong>。</p>
<p>基于这个特性,可以实现另一种线程安全的延迟初始化方案(这个方案被称之为<br>Initialization On Demand Holder idiom)。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210505201126.png" alt=""></p>
<p>假设两个线程并发执行getInstance()方法,下面是执行的示意图,如图3-40所示。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210505201204.png" alt=""></p>
<p>这个方案的实质是:允许3行伪代码中的2和3重排序，但<strong>不允许非构造线程(这里指线程B)“看到”这个重排序</strong>。</p>
<p>初始化一个类,包括执行这个类的静态初始化和初始化在这个类中声明的静态字段。根据Java语言规范,在首次发生下列任意一种情况时，一个类或接口类型T将被立即初始化。</p>
<ul>
<li>1)T是一个类,而且一个T类型的实例被创建。</li>
<li>2)T是一个类，且T中声明的一个静态方法被调用。</li>
<li>3)T中声明的一个静态字段被赋值。</li>
<li>4)T中声明的一个静态字段被使用，而且这个字段不是一个常量字段。</li>
<li>5)T是一个顶级类(Top Level Class，见Java语言规范的$7.6),而且一个断言语句嵌套在T内部被执行。</li>
</ul>
<p>Java语言规范规定, 对于每一个类或接口C,都有一个唯一的初始化锁LC与之对应。从C到LC的映射，由JVM的具体实现去自由实现。JVM在类初始化期间会获取这个初始化锁,并且<strong>每个线程至少获取一次锁来确保这个类已经被初始化过了</strong>。</p>
<p>对于类或接口的初始化,Java语言规范制定了精巧而复杂的类初始化处理过程。Java初始化一个类或接口的处理过程如下：</p>
<ul>
<li>第1阶段: 通过在Class对象上同步(即获取Class对象的初始化锁)，来控制类或接口的初始化。这个获取锁的线程会一直等待, 直到当前线程能够获取到这个初始化锁。</li>
<li>第2阶段:线程A执行类的初始化，同时线程B在初始化锁对应的condition上等待。</li>
<li>第3阶段:线程A设置state=initialized，然后唤醒在condition中等待的所有线程。</li>
<li>第4阶段:线程B结束类的初始化处理。</li>
<li>第5阶段:线程C执行类的初始化的处理。</li>
</ul>
<p>在第3阶段之后，类已经完成了初始化。因此线程C在第5阶段的类初始化处理过程相对简单一些(前面的线程A和B的类初始化处理过程都经历了两次锁获取-锁释放,而线程C的类初始化处理只需要经历一次锁获取-锁释放)。</p>
<p>通过对比基于volatile的双重检查锁定的方案和基于类初始化的方案，我们会发现基于类初始化的方案的实现代码更简洁。但<strong>基于volatile</strong>的双重检查锁定的方案有一个额外的优势:除了可以对<strong>静态字段实现延迟初始化</strong>外, <strong>还可以对实例字段实现延迟初始化</strong>。</p>
<p>字段延迟初始化降低了初始化类或创建实例的开销,但增加了访问被延迟初始化的字段的开销。在大多数时候，正常的初始化要优于延迟初始化。如果确实需要<strong>对实例字段</strong>使用线程安全的延迟初始化,请使用上面介绍的<strong>基于volatile</strong>的延迟初始化的方案;如果确实需要<strong>对静态字段</strong>使用线程安全的延迟初始化，请使用上面介绍的<strong>基于类初始化</strong>的方案。</p>
<h2 id="Java内存模型综述"><a href="#Java内存模型综述" class="headerlink" title="Java内存模型综述"></a>Java内存模型综述</h2><h3 id="处理器的内存模型"><a href="#处理器的内存模型" class="headerlink" title="处理器的内存模型"></a>处理器的内存模型</h3><p>顺序一致性内存模型是一个理论参考模型,JMM和处理器内存模型在设计时通常会以顺序一致性内存模型为参照。在设计时，JMM和处理器内存模型会对顺序一致性模型做一些放松,因为如果完全按照顺序一致性模型来实现处理器和JMM，那么很多的处理器和编译器优化都要被禁止，这对执行性能将会有很大的影响。</p>
<p>根据对不同类型的读/写操作组合的执行顺序的放松,可以把常见处理器的内存模型划分为如下几种类型。</p>
<ul>
<li>放松程序中写-读操作的顺序,由此产生了Total Store Ordering内存模型(简称为TSO)。</li>
<li>在上面的基础上，继续放松程序中写-写操作的顺序，由此产生了Partial Store Order内存模型(简称为PSO)。</li>
<li>在前面两条的基础上,继续放松程序中读-写和读-读操作的顺序,由此产生了RelaxedMemory Order内存模型(简称为RMO)和PowerPC内存模型。</li>
</ul>
<p>注意，这里处理器对读/写操作的放松，是以两个操作之间不存在数据依赖性为前提的(因为处理器要遵守as-if-serial语义,处理器不会对存在数据依赖性的两个内存操作做重排序)。</p>
<p>表3-12展示了常见处理器内存模型的细节特征如下。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210505205144.png" alt=""></p>
<p>从表3-12中可以看到，所有处理器内存模型<strong>都允许写-读重排序</strong>，原因在：<strong>它们都使用了写缓存区</strong>。写缓存区可能导致写-读操作重排序。同时，我们可以看到这些处理器内存模型都允许更早读到当前处理器的写,原因同样是因为写缓存区。由于写缓存区仅对当前处理器可见,这个特性导致当前处理器可以比其他处理器先看到临时保存在自己写缓存区中的写。</p>
<p>表3-12中的各种处理器内存模型,从上到下，模型由强变弱。<strong>越是追求性能的处理器,内存模型设计得会越弱</strong>。因为这些处理器希望内存模型对它们的<strong>束缚越少越好</strong>,这样它们就可以做尽可能多的优化来提高性能。</p>
<h3 id="JMM的内存可见性保证"><a href="#JMM的内存可见性保证" class="headerlink" title="JMM的内存可见性保证"></a>JMM的内存可见性保证</h3><p>按程序类型, Java程序的内存可见性保证可以分为下列3类。</p>
<ul>
<li>单线程程序。单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</li>
<li>正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性(程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同)。这是JMM关注的重点，JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。</li>
<li>未同步/未正确同步的多线程程序。JMM为它们提供了最小安全性保障:线程执行时读取到的值,要么是之前某个线程写入的值，要么是默认值(O、null、false)。</li>
</ul>
<p>注意,最小安全性保障与64位数据的非原子性写并不矛盾。它们是两个不同的概念，它们发生”的时间点也不同。</p>
<p>最小安全性保证对象默认初始化之后(设置成员域为0、mul1或false),才会被任意线程使用。</p>
<p>最小安全性“发生”在对象被任意线程使用之前。64位数据的非原子性写“发生”在对象被多个线程使用的过程中(写共享变量)。</p>
<p>当发生问题时(处理器B看到仅仅被处理器A“写了一半”的无效值)，这里虽然处理器B读取到一个被写了一半的无效值,但这个值仍然是处理器A写入的,只不过是处理器A还没有写完而已。最小安全性保证线程读取到的值，要么是之前某个线程写入的值，要么是默认值(o、mull、false)。但最小安全性并不保证线程读取到的值,一定是某个线程写完后的值。<strong>最小安全性保证线程读取到的值不会无中生有的冒出来,但并不保证线程读取到的值一定是正确的</strong>。</p>
<p>图3-50展示了这3类程序在JMM中与在顺序一致性内存模型中的执行结果的异同。<br>只要多线程程序是<strong>正确同步</strong>的,JMM保证该程序在任意的处理器平台上的执行结果,与该程序在顺序一致性内存模型中的执行结果一致。</p>
<p><img src="https://gitee.com/hlgao666/image-depot/raw/master/static/20210505210012.png" alt=""></p>
<h3 id="JSR-133对旧内存模型的修补"><a href="#JSR-133对旧内存模型的修补" class="headerlink" title="JSR-133对旧内存模型的修补"></a>JSR-133对旧内存模型的修补</h3><p>JSR-133对JDK5之前的旧内存模型的修补主要有两个。</p>
<ul>
<li><strong>增强volatile的内存语义</strong>。旧内存模型允许volatile变量与普通变量重排序。JSR-133严格限制volatile变量与普通变量的重排序，使volatile的写-读和锁的释放-获取具有相同的内存语义。</li>
<li><strong>增强final的内存语义</strong>。在旧内存模型中,多次读取同一个final变量的值可能会不相同。为此,JSR-133为final增加了两个重排序规则。在保证final引用不会从构造函数内逸出的情况下，final具有了初始化安全性。</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Hailong Gao</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://hlgao666.github.io/2021/06/22/多线程/2-Java内存模型/">https://hlgao666.github.io/2021/06/22/多线程/2-Java内存模型/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Hailong Gao</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/volatile/">
                                    <span class="chip bg-color">volatile</span>
                                </a>
                            
                                <a href="/tags/JMM/">
                                    <span class="chip bg-color">JMM</span>
                                </a>
                            
                                <a href="/tags/重排序/">
                                    <span class="chip bg-color">重排序</span>
                                </a>
                            
                                <a href="/tags/happens-before/">
                                    <span class="chip bg-color">happens-before</span>
                                </a>
                            
                                <a href="/tags/双重检查锁定/">
                                    <span class="chip bg-color">双重检查锁定</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/medias/reward/wechat.jpg" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '71b3fe32e349132d133e',
        clientSecret: '1c6066aad8a2feaccbdf64f42194f3dfef3eb0e0',
        repo: 'hlgao666.github.io',
        owner: 'hlgao666',
        admin: "hlgao666",
        id: '2021-06-22T14-25-50',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2021/06/22/多线程/3-Java并发编程基础/">
                    <div class="card-image">
                        
                        <img src="/medias/featureimages/71.jpg" class="responsive-img" alt="3 Java并发编程基础">
                        
                        <span class="card-title">3 Java并发编程基础</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Java并发编程基础
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-06-22
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/多线程/" class="post-category">
                                    多线程
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/创建线程/">
                        <span class="chip bg-color">创建线程</span>
                    </a>
                    
                    <a href="/tags/线程的启动终止/">
                        <span class="chip bg-color">线程的启动终止</span>
                    </a>
                    
                    <a href="/tags/线程间通信/">
                        <span class="chip bg-color">线程间通信</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/06/22/多线程/1-并发编程基础知识/">
                    <div class="card-image">
                        
                        <img src="/medias/featureimages/69.jpg" class="responsive-img" alt="1 并发编程基础知识">
                        
                        <span class="card-title">1 并发编程基础知识</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            并发编程基础知识
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-06-22
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/多线程/" class="post-category">
                                    多线程
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/死锁/">
                        <span class="chip bg-color">死锁</span>
                    </a>
                    
                    <a href="/tags/上下文切换/">
                        <span class="chip bg-color">上下文切换</span>
                    </a>
                    
                    <a href="/tags/volatile/">
                        <span class="chip bg-color">volatile</span>
                    </a>
                    
                    <a href="/tags/synchronized/">
                        <span class="chip bg-color">synchronized</span>
                    </a>
                    
                    <a href="/tags/Java对象头/">
                        <span class="chip bg-color">Java对象头</span>
                    </a>
                    
                    <a href="/tags/锁的升级/">
                        <span class="chip bg-color">锁的升级</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="488982301"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="/about" target="_blank">Hailong Gao</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">364.2k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2019";
                    var startMonth = "09";
                    var startDate = "28";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/hlgao666" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1330695688@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1330695688" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1330695688" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/search.xml", 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/libs/background/canvas-nest.js"></script>
    

    
    
    <script type="text/javascript" size="150" alpha='0.6'
        zIndex="-1" src="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/libs/background/ribbon-refresh.min.js" async="async"></script>
    

    
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="https://cdn.jsdelivr.net/gh/hlgao666/hlgao666.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
