<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>求解最短路问题的两种经典算法</title>
      <link href="/2019/10/10/%E6%B1%82%E8%A7%A3%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"/>
      <url>/2019/10/10/%E6%B1%82%E8%A7%A3%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Dijkstra-amp-Floyd-Algorithm"><a href="#Dijkstra-amp-Floyd-Algorithm" class="headerlink" title="Dijkstra &amp; Floyd Algorithm"></a>Dijkstra &amp; Floyd Algorithm</h1><p>转自： <a href="https://www.jianshu.com/p/ff6db00ad866" target="_blank" rel="noopener">https://www.jianshu.com/p/ff6db00ad866</a></p><p>Dijkstra算法用于解决有权图的单源最短路问题，Floyd算法用于解决有权图的多源最短路问题。</p><h2 id="Dijkstra-algorithm"><a href="#Dijkstra-algorithm" class="headerlink" title="Dijkstra algorithm"></a>Dijkstra algorithm</h2><blockquote><p>迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。  </p></blockquote><p><img src="/../images/image021.jpg" alt="图1"></p><p>指定A作为“源点”，问题就是求A到其他节点的最短路径。</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><pre class=" language-bash"><code class="language-bash">1.指定一个节点，例如我们要计算 <span class="token string">'A'</span> 到其他节点的最短路径  2.引入两个集合（S、U），S集合包含已求出的最短路径的点（以及相应的最短长度），U集合包含未求出最短路径的点（以及A到该点的路径，注意:如上图1所示，A-<span class="token operator">></span>C由于没有直接边相连，初始时置为∞）  3.初始化两个集合，S集合初始时 只有当前要计算的节点，A-<span class="token operator">></span>A <span class="token operator">=</span> 0，U集合初始时为 A-<span class="token operator">></span>B <span class="token operator">=</span> 4, A-<span class="token operator">></span>C <span class="token operator">=</span> ∞, A-<span class="token operator">></span>D <span class="token operator">=</span> 2, A-<span class="token operator">></span>E <span class="token operator">=</span> ∞  4.从U集合中找出路径最短的点，加入S集合，例如 A-<span class="token operator">></span>D <span class="token operator">=</span> 2  5.更新U集合路径，if <span class="token punctuation">(</span> <span class="token string">'D 到 B,C,E 的距离'</span> + <span class="token string">'AD 距离'</span> <span class="token operator">&lt;</span> <span class="token string">'A 到 B,C,E 的距离'</span> <span class="token punctuation">)</span> 则更新U  6.循环执行 4、5 两步骤，直至遍历结束，得到A到其他节点的最短路径.</code></pre><h3 id="算法图解"><a href="#算法图解" class="headerlink" title="算法图解"></a>算法图解</h3><p>1.选定A节点并初始化，如上述步骤3所示</p><p><img src="/../images/image022.jpg" alt="图2"></p><p>2.执行上述 4、5两步骤，找出U集合中路径最短的节点D 加入S集合，并根据条件 if ( ‘D 到 B,C,E 的距离’ + ‘AD 距离’ &lt; ‘A 到 B,C,E 的距离’ ) 来更新U集合  </p><p><img src="/../images/image023.jpg" alt="图3"></p><p>3.这时候 A-&gt;B, A-&gt;C 都为3，没关系。其实这时候他俩都是最短距离，如果从算法逻辑来讲的话，会先取到B点。而这个时候 if 条件变成了 if ( ‘B 到 C,E 的距离’ + ‘AB 距离’ &lt; ‘A 到 C,E 的距离’ ) ，如图所示这时候A-&gt;B距离 其实为 A-&gt;D-&gt;B  </p><p><img src="/../images/image024.jpg" alt="图4"></p><p>4.思路就是这样，往后就是大同小异了</p><p><img src="/../images/image025.jpg" alt="图5"></p><p>5.算法结束</p><p><img src="/../images/image026.jpg" alt="图6"></p><h3 id="代码实现-java"><a href="#代码实现-java" class="headerlink" title="代码实现(java)"></a>代码实现(java)</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Dijkstra</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> M <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 代表正无穷</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 二维数组每一行分别是 A、B、C、D、E 各点到其余点的距离, </span>        <span class="token comment" spellcheck="true">// A -> A 距离为0, 常量M 为正无穷</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> weight1 <span class="token operator">=</span> <span class="token punctuation">{</span>                <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span>M<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>M<span class="token punctuation">}</span><span class="token punctuation">,</span>                 <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>M<span class="token punctuation">}</span><span class="token punctuation">,</span>                 <span class="token punctuation">{</span>M<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                 <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                   <span class="token punctuation">{</span>M<span class="token punctuation">,</span>M<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span>             <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> shortPath <span class="token operator">=</span> <span class="token function">dijkstra</span><span class="token punctuation">(</span>weight1<span class="token punctuation">,</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> shortPath<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"从"</span> <span class="token operator">+</span> start <span class="token operator">+</span> <span class="token string">"出发到"</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">"的最短距离为："</span> <span class="token operator">+</span> shortPath<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">dijkstra</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> weight<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 接受一个有向图的权重矩阵，和一个起点编号start（从0编号，顶点存在数组中）</span>        <span class="token comment" spellcheck="true">// 返回一个int[] 数组，表示从start到它的最短路径长度</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> weight<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 顶点个数</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> shortPath <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 保存start到其他各点的最短路径</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 保存start到其他各点最短路径的字符串表示</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            path<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>start <span class="token operator">+</span> <span class="token string">"-->"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 标记当前该顶点的最短路径是否已经求出,1表示已求出</span>        <span class="token comment" spellcheck="true">// 初始化，第一个顶点已经求出</span>        shortPath<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        visited<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> count <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> count<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 要加入n-1个顶点</span>            <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 选出一个距离初始顶点start最近的未标记顶点</span>            <span class="token keyword">int</span> dmin <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> weight<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dmin<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dmin <span class="token operator">=</span> weight<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                    k <span class="token operator">=</span> i<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 将新选出的顶点标记为已求出最短路径，且到start的最短路径就是dmin</span>            shortPath<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> dmin<span class="token punctuation">;</span>            visited<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 以k为中间点，修正从start到未访问各点的距离</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//如果 '起始点到当前点距离' + '当前点到某点距离' &lt; '起始点到某点距离', 则更新</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> weight<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> weight<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> weight<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    weight<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> weight<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> weight<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                    path<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> path<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">"-->"</span> <span class="token operator">+</span> i<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"从"</span> <span class="token operator">+</span> start <span class="token operator">+</span> <span class="token string">"出发到"</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">"的最短路径为："</span> <span class="token operator">+</span> path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"====================================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> shortPath<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h2 id="Floyd-algorithm"><a href="#Floyd-algorithm" class="headerlink" title="Floyd algorithm"></a>Floyd algorithm</h2><blockquote><p>Floyd算法又称为插点法，是一种利用动态规划的思想寻找给定的加权图中多源点之间最短路径的算法，与Dijkstra算法类似。  </p></blockquote><p>求解多源最短路问题的2种方法：</p><p>1.直接把Dijkstra调用|V|遍，时间复杂度为O(V^3);</p><p>2.Floyd算法更简洁，但算法复杂度仍为O(V^3)。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dijkstra &amp; Floyd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小生成树的两种经典算法</title>
      <link href="/2019/10/09/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"/>
      <url>/2019/10/09/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Prim-amp-Kruskal-Algorithm"><a href="#Prim-amp-Kruskal-Algorithm" class="headerlink" title="Prim &amp; Kruskal Algorithm"></a>Prim &amp; Kruskal Algorithm</h2><p>转自：<a href="https://blog.csdn.net/qq_36951116/article/details/83089039" target="_blank" rel="noopener">https://blog.csdn.net/qq_36951116/article/details/83089039</a></p><p>问题引出：假设要在n个城市之间建立通信网，则连通n个城市只需要n-1条线路。这时自然会考虑一个问题：如何在最节省经费的前提下建立这个通信网？  </p><hr><h3 id="MST-minimal-spanning-treeproblem"><a href="#MST-minimal-spanning-treeproblem" class="headerlink" title="MST(minimal spanning treeproblem)"></a>MST(minimal spanning treeproblem)</h3><p>可以用连通网来表示n个城市以及n个城市之间的通信线路，其中，网的顶点表示城市，边表示两城市之间的线路，赋予边权值表示开设相应线路的代价。  </p><p>这个问题就是最小生成树问题：求解连通无向图的权最小的生成树  </p><p>Prim &amp; Kruskal Algorithm 是利用MST性质构造最小生成树的两种算法。Prim算法用于稠密图效果更好，Kruskal算法则更适用于稀疏图。  </p><h3 id="MST性质"><a href="#MST性质" class="headerlink" title="MST性质"></a>MST性质</h3><p>设G=(V，E)是一个连通网络，U是顶点集V的一个真子集。若(u，v)是G中一条“一个端点在U中(例如：u∈U)，另一个端点不在U中”的边(例如：v∈V-U)，且(u，v)具有最小权值，则一定存在G的一棵最小生成树包括此边(u，v)。  </p><p>证明略去，具体可参考： <a href="https://blog.csdn.net/s_j_huang/article/details/79447041" target="_blank" rel="noopener">https://blog.csdn.net/s_j_huang/article/details/79447041</a></p><h3 id="Prim-algorithm"><a href="#Prim-algorithm" class="headerlink" title="Prim algorithm"></a>Prim algorithm</h3><pre class=" language-bash"><code class="language-bash">算法思路：从已选顶点所关联的未选边中找出权重最小的边，并且生成树不存在环。  其中，已选顶点是构成最小生成树的结点，未选边是不属于生成树中的边。 （普里姆算法与求最短路径的迪杰斯塔拉算法思想很类似）  </code></pre><p>下面我们对下面这幅图求其最小生成树：</p><p><img src="/../images/image008.jpg" alt="图1"></p><p>假设我们从顶点v1开始，所以我们可以发现（v1,v3）边的权重最小，所以第一个输出的边就是：v1—v3=1,  </p><p><img src="/../images/image009.jpg" alt="图2"></p><p>然后，我们要从v1和v3作为起点的边中寻找权重最小的边，首先了（v1,v3）已经访问过了，所以我们从其他边中寻找，发现(v3,v6)这条边最小，所以输出边就是：v3—-v6=4,  </p><p><img src="/../images/image010.jpg" alt="图3"></p><p>然后，我们要从v1、v3、v6这三个点相关联的边中寻找一条权重最小的边，我们可以发现边(v6,v4)权重最小，所以输出边就是：v6—-v4=2,  </p><p><img src="/../images/image011.jpg" alt="图4"></p><p>然后，我们就从v1、v3、v6、v4这四个顶点相关联的边中寻找权重最小的边，发现边（v3，v2）的权重最小，所以输出边：v3—–v2=5,  </p><p><img src="/../images/image012.jpg" alt="图5"></p><p>然后，我们就从v1、v3、v6、v4，v2这2五个顶点相关联的边中寻找权重最小的边，发现边（v2，v5）的权重最小，所以输出边：v2—–v5=3,  </p><p><img src="/../images/image013.jpg" alt="图6"></p><p>最后，我们发现六个点都已经加入到集合U了，我们的最小生成树建立完成。  </p><h3 id="Kruskal-algorithm"><a href="#Kruskal-algorithm" class="headerlink" title="Kruskal algorithm"></a>Kruskal algorithm</h3><pre class=" language-bash"><code class="language-bash">算法思路： （1）将边按权值从小到大的顺序添加到新图中，保证添加的过程中不会形成环 （2）重复上一步直到连接所有顶点，此时就生成了最小生成树。这是一种贪心策略。将图中所有边按照权重的大小 从小到大一个一个按顺序组合成最小生成树，在组合过程新加入的边会导致生成树形成环，那这条边就舍弃，直到所有顶点都添加到生成树中为止。  </code></pre><p>这里同样我们给出一个和Prim算法讲解中同样的例子，模拟克鲁斯卡算法生成最小生成树的详细的过程：  </p><p>首先完整的图如下图： </p><p><img src="/../images/image014.jpg" alt="图7"></p><p>然后，我们需要从这些边中找出权重最小的那条边，可以发现边（v1，v3）这条边的权重是最小的，所以我们输出边：v1—-v3=1,  </p><p><img src="/../images/image015.jpg" alt="图8"></p><p>然后，我们需要在剩余的边中，再次寻找一条权重最小的边，可以发现边（v4，v6）这条边的权重最小，所以输出边：v4—v6=2,    </p><p><img src="/../images/image016.jpg" alt="图9"></p><p>然后，我们再次从剩余边中寻找权重最小的边，发现边（v2，v5）的权重最小，所以可以输出边：v2—-v5=3,  </p><p><img src="/../images/image017.jpg" alt="图10"></p><p>然后，我们使用同样的方式找出了权重最小的边：（v3，v6），所以我们输出边：v3—-v6=4,  </p><p><img src="/../images/image018.jpg" alt="图11"></p><p>好了，现在我们还需要找出最后一条边就可以构造出一颗最小生成树，但是这个时候我们有三个选择：（v1,V4），（v2，v3），（v3，v4）,这三条边的权重都是5，首先我们如果选（v1，v4）的话，得到的图如下:  </p><p><img src="/../images/image019.jpg" alt="图12"></p><p>我们发现，这肯定是不符合我们算法要求的，因为它出现了一个环，所以我们再使用第二个（v2，v3）试试，得到图形如下：  </p><p><img src="/../images/image020.jpg" alt="图13"></p><p>我们发现，这个图中没有环出现，而且把所有的顶点都加入到了这颗树上了，所以（v2，v3）就是我们所需要的边，所以最后一个输出的边就是：v2—-v3=5.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Prim &amp; Kruskal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A-Star Algorithm</title>
      <link href="/2019/09/27/A-Star-Algorithm/"/>
      <url>/2019/09/27/A-Star-Algorithm/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="A-Star-Algorithm"><a href="#A-Star-Algorithm" class="headerlink" title="A-Star Algorithm"></a>A-Star Algorithm</h2><p>转自：<a href="https://blog.csdn.net/qq_36946274/article/details/81982691" target="_blank" rel="noopener">https://blog.csdn.net/qq_36946274/article/details/81982691</a></p><h3 id="1-搜索区域-The-Search-Area"><a href="#1-搜索区域-The-Search-Area" class="headerlink" title="1.搜索区域(The Search Area)"></a>1.搜索区域(The Search Area)</h3><pre class=" language-bash"><code class="language-bash">A*算法是一种在静态路网中求解最短路径问题的最直接方法，问题可描述如下：  我们假设某人要从 A 点移动到 B 点，但是这两点之间被一堵墙隔开。如图 1 ，绿色是 A ，红色是 B ，中间蓝色是墙。  </code></pre><p><img src="/../images/image001.jpg" alt="图1"></p><p>你应该注意到了，我们把要搜寻的区域划分成了正方形的格子。这是寻路的第一步，简化搜索区域，就像我们这里做的一样。这个特殊的方法把我们的搜索区域简化为了 2 维数组。数组的每一项代表一个格子，它的状态就是可走 (walkalbe) 和不可走 (unwalkable) 。通过计算出从 A 到 B需要走过哪些方格，就找到了路径。一旦路径找到了，人物便从一个方格的中心移动到另一个方格的中心，直至到达目的地。  </p><p>方格的中心点我们成为“节点 (nodes) ”。如果你读过其他关于 A-Star寻路算法的文章，你会发现人们常常都在讨论节点。为什么不直接描述为方格呢？因为我们有可能把搜索区域划为为其他多变形而不是正方形，例如可以是六边形，矩形，甚至可以是任意多变形。而节点可以放在任意多边形里面，可以放在多变形的中心，也可以放在多边形的边上。我们使用这个系统，因为它最简单。</p><h3 id="2-开始搜索-Starting-the-Search"><a href="#2-开始搜索-Starting-the-Search" class="headerlink" title="2.开始搜索(Starting the Search)"></a>2.开始搜索(Starting the Search)</h3><p>一旦我们把搜寻区域简化为一组可以量化的节点后，就像上面做的一样，我们下一步要做的便是查找最短路径。在 A* 中，我们从起点开始，检查其相邻的方格，然后向四周扩展，直至找到目标。  </p><pre class=" language-bash"><code class="language-bash">我们这样开始我们的寻路旅途：1.从起点 A 开始，并把它就加入到一个由方格组成的 <span class="token function">open</span> list<span class="token punctuation">(</span> 开放列表 <span class="token punctuation">)</span> 中。这个 <span class="token function">open</span> list 有点像是一个购物单。当然现在 <span class="token function">open</span> list 里只有一项，它就是起点 A ，后面会慢慢加入更多的项。 Open list 里的格子是路径可能会是沿途经过的，也有可能不经过。基本上 <span class="token function">open</span> list 是一个待检查的方格列表。  2.查看与起点 A 相邻的方格 <span class="token punctuation">(</span> 忽略其中墙壁所占领的方格，河流所占领的方格及其他非法地形占领的方格 <span class="token punctuation">)</span> ，把其中可走的 <span class="token punctuation">(</span>walkable<span class="token punctuation">)</span> 或可到达的 <span class="token punctuation">(</span>reachable<span class="token punctuation">)</span> 方格也加入到 <span class="token function">open</span> list 中。把起点 A 设置为这些方格的父亲 <span class="token punctuation">(</span>parent node 或 parent square<span class="token punctuation">)</span> 。当我们在追踪路径时，这些父节点的内容是很重要的。稍后解释。  3.把 A 从 <span class="token function">open</span> list 中移除，加入到 close list<span class="token punctuation">(</span> 封闭列表 <span class="token punctuation">)</span> 中， close list 中的每个方格都是现在不需要再关注的。  </code></pre><p>如下图2所示，深绿色的方格为起点，它的外框是亮蓝色，表示该方格被加入到了 close list 。与它相邻的黑色方格是需要被检查的，他们的外框是亮绿色。每个黑方格都有一个灰色的指针指向他们的父节点，这里是起点 A 。<br><img src="/../images/image002.jpg" alt="图2"></p><p>下一步，我们需要从 open list 中选一个与起点 A 相邻的方格，按下面描述的一样或多或少的重复前面的步骤。但是到底选择哪个方格好呢？具有最小 F 值的那个。  </p><h3 id="3-路径排序-Path-Sorting"><a href="#3-路径排序-Path-Sorting" class="headerlink" title="3.路径排序(Path Sorting)"></a>3.路径排序(Path Sorting)</h3><p>计算出组成路径的方格的关键是下面这个等式：</p><center><font faceface="微软雅黑" color="red" size="10">F = G + H</font></center><pre class=" language-bash"><code class="language-bash">这里，G <span class="token operator">=</span> 从起点 A 移动到指定方格的移动代价，沿着到达该方格而生成的路径。  H <span class="token operator">=</span> 从指定的方格移动到终点 B 的估算成本。这个通常被称为试探法，有点让人混淆。为什么这么叫呢，因为这是个猜测。直到我们找到了路径我们才会知道真正的距离，因为途中有各种各样的东西 <span class="token punctuation">(</span> 比如墙壁，水等 <span class="token punctuation">)</span> 。本教程将教你一种计算 H 的方法，你也可以在网上找到其他方法。  </code></pre><p>我们的路径是这么产生的：反复遍历 open list ，选择 F 值最小的方格。这个过程稍后详细描述。我们还是先看看怎么去计算上面的等式。  </p><pre class=" language-bash"><code class="language-bash">如上所述， G 是从起点Ａ移动到指定方格的移动代价。在本例中，横向和纵向的移动代价为 10 ，对角线的移动代价为 14 。之所以使用这些数据，是因为实际的对角移动距离是 2 的平方根，或者是近似的 1.414 倍的横向或纵向移动代价。使用 10 和 14 就是为了简单起见。比例是对的，我们避免了开放和小数的计算。这并不是我们没有这个能力或是不喜欢数学。使用这些数字也可以使计算机更快。稍后你便会发现，如果不使用这些技巧，寻路算法将很慢。  既然我们是沿着到达指定方格的路径来计算 G 值，那么计算出该方格的 G 值的方法就是找出其父亲的 G 值，然后按父亲是直线方向还是斜线方向加上 10 或 14 。随着我们离开起点而得到更多的方格，这个方法会变得更加明朗。  有很多方法可以估算 H 值。这里我们使用 Manhattan 方法，计算从当前方格横向或纵向移动到达目标所经过的方格数，忽略对角移动，然后把总数乘以 10 。之所以叫做 Manhattan 方法，是因为这很像统计从一个地点到另一个地点所穿过的街区数，而你不能斜向穿过街区。重要的是，计算 H 是，要忽略路径中的障碍物。这是对剩余距离的估算值，而不是实际值，因此才称为试探法。  把 G 和 H 相加便得到 F 。我们第一步的结果如下图所示。每个方格都标上了 F ， G ， H 的值，就像起点右边的方格那样，左上角是 F ，左下角是 G ，右下角是 H 。  </code></pre><p><img src="/../images/image003.jpg" alt="图3"></p><p>好，现在让我们看看其中的一些方格。在标有字母的方格， G = 10 。这是因为水平方向从起点到那里只有一个方格的距离。与起点直接相邻的上方，下方，左方的方格的 G 值都是 10 ，对角线的方格 G 值都是 14 。  </p><p>H 值通过估算起点于终点 ( 红色方格 ) 的 Manhattan 距离得到，仅作横向和纵向移动，并且忽略沿途的墙壁。使用这种方式，起点右边的方格到终点有 3 个方格的距离，因此 H = 30 。这个方格上方的方格到终点有 4 个方格的距离 ( 注意只计算横向和纵向距离 ) ，因此 H = 40 。对于其他的方格，你可以用同样的方法知道 H 值是如何得来的。  </p><p>每个方格的 F 值，再说一次，直接把 G 值和 H 值相加就可以了。  </p><h3 id="4-继续搜索-Continuing-the-Search"><a href="#4-继续搜索-Continuing-the-Search" class="headerlink" title="4.继续搜索(Continuing the Search)"></a>4.继续搜索(Continuing the Search)</h3><p>为了继续搜索，我们从 open list 中选择 F 值最小的 ( 方格 ) 节点，然后对所选择的方格作如下操作：  </p><pre class=" language-bash"><code class="language-bash">1.把它从 <span class="token function">open</span> list 里取出，放到 close list 中。  2.检查所有与它相邻的方格，忽略其中在 close list 中或是不可走 <span class="token punctuation">(</span>unwalkable<span class="token punctuation">)</span> 的方格 <span class="token punctuation">(</span> 比如墙，水，或是其他非法地形 <span class="token punctuation">)</span> ，如果方格不在open lsit 中，则把它们加入到 <span class="token function">open</span> list 中。  把我们选定的方格设置为这些新加入的方格的父亲。1.如果某个相邻的方格已经在 <span class="token function">open</span> list 中，则检查这条路径是否更优，也就是说经由当前方格 <span class="token punctuation">(</span> 我们选中的方格 <span class="token punctuation">)</span> 到达那个方格是否具有更小的 G 值。如果没有，不做任何操作。  2.相反，如果 G 值更小，则把那个方格的父亲设为当前方格 <span class="token punctuation">(</span> 我们选中的方格 <span class="token punctuation">)</span> ，然后重新计算那个方格的 F 值和 G 值。如果你还是很混淆，请参考下图4。  </code></pre><p><img src="/../images/image004.jpg" alt="图4"></p><p>OK ，让我们看看它是怎么工作的。在我们最初的 9 个方格中，还有 8 个在 open list 中，起点被放入了 close list 中。在这些方格中，起点右边的格子的 F 值 40 最小，因此我们选择这个方格作为下一个要处理的方格。它的外框用蓝线打亮。  </p><p>首先，我们把它从 open list 移到 close list 中 ( 这就是为什么用蓝线打亮的原因了 ) 。然后我们检查与它相邻的方格。它右边的方格是墙壁，我们忽略。它左边的方格是起点，在 close list 中，我们也忽略。其他 4 个相邻的方格均在 open list 中，我们需要检查经由这个方格到达那里的路径是否更好，使用 G 值来判定。让我们看看上面的方格。它现在的 G 值为 14 。如果我们经由当前方格到达那里， G 值将会为 20(其中 10 为到达当前方格的 G 值，此外还要加上从当前方格纵向移动到上面方格的 G 值 10) 。显然 20 比 14 大，因此这不是最优的路径。如果你看图你就会明白。直接从起点沿对角线移动到那个方格比先横向移动再纵向移动要好。  </p><p>当把 4 个已经在 open list 中的相邻方格都检查后，没有发现经由当前方格的更好路径，因此我们不做任何改变。现在我们已经检查了当前方格的所有相邻的方格，并也对他们作了处理，是时候选择下一个待处理的方格了。  </p><p>因此再次遍历我们的 open list ，现在它只有 7 个方格了，我们需要选择 F 值最小的那个。有趣的是，这次有两个方格的 F 值都 54 ，选哪个呢？没什么关系。从速度上考虑，选择最后加入 open list 的方格更快。这导致了在寻路过程中，当靠近目标时，优先使用新找到的方格的偏好。但是这并不重要。 ( 对相同数据的不同对待，导致两中版本的 A* 找到等长的不同路径 ) 。  </p><p>我们选择起点右下方的方格，如下图5所示。</p><p><img src="/../images/image005.jpg" alt="图5"></p><p>这次，当我们检查相邻的方格时，我们发现它右边的方格是墙，忽略之。上面的也一样。  </p><p>我们把墙下面的一格也忽略掉。为什么？因为如果不穿越墙角的话，你不能直接从当前方格移动到那个方格。你需要先往下走，然后再移动到那个方格，这样来绕过墙角。 ( 注意：穿越墙角的规则是可选的，依赖于你的节点是怎么放置的 )  </p><p>这样还剩下 5 个相邻的方格。当前方格下面的 2 个方格还没有加入 open list ，所以把它们加入，同时把当前方格设为他们的父亲。在剩下的3 个方格中，有 2 个已经在 close list 中 ( 一个是起点，一个是当前方格上面的方格，外框被加亮的 ) ，我们忽略它们。最后一个方格，也就是当前方格左边的方格，我们检查经由当前方格到达那里是否具有更小的 G 值。没有。因此我们准备从 open list 中选择下一个待处理的方格。  </p><p>不断重复这个过程，直到把终点也加入到了 open list 中，此时如下图6所示。  </p><p><img src="/../images/image006.jpg" alt="图6"></p><p>注意，在起点下面 2 格的方格的父亲已经与前面不同了。之前它的 G 值是 28 并且指向它右上方的方格。现在它的 G 值为 20 ，并且指向它正上方的方格。这在寻路过程中的某处发生，使用新路径时 G 值经过检查并且变得更低，因此父节点被重新设置， G 和 F 值被重新计算。尽管这一变化在本例中并不重要，但是在很多场合中，这种变化会导致寻路结果的巨大变化。  </p><p>那么我们怎么样去确定实际路径呢？很简单，从终点开始，按着箭头向父节点移动，这样你就被带回到了起点，这就是你的路径。如下图所示。从起点 A 移动到终点 B 就是简单从路径上的一个方格的中心移动到另一个方格的中心，直至目标。就是这么简单！  </p><p><img src="/../images/image007.jpg" alt="图7"></p><h3 id="5-A-Star-Algorithm-Summary"><a href="#5-A-Star-Algorithm-Summary" class="headerlink" title="5.A-Star Algorithm Summary"></a>5.A-Star Algorithm Summary</h3><p>Ok ，现在你已经看完了整个的介绍，现在我们把所有步骤放在一起：  </p><pre class=" language-bash"><code class="language-bash">1.把起点加入 <span class="token function">open</span> list 。2.重复如下过程：    a<span class="token punctuation">)</span>遍历 <span class="token function">open</span> list ，查找 F 值最小的节点，把它作为当前要处理的节点。      b<span class="token punctuation">)</span>把这个节点移到 close list 。      c<span class="token punctuation">)</span>对当前方格的 8 个相邻方格的每一个方格:        ◆ 如果它是不可抵达的或者它在 close list 中，忽略它。否则，做如下操作。         ◆ 如果它不在 <span class="token function">open</span> list 中，把它加入 <span class="token function">open</span> list ，并且把当前方格设置为它的父亲，记录该方格的 F ， G 和 H 值。          ◆ 如果它已经在 <span class="token function">open</span> list 中，检查这条路径 <span class="token punctuation">(</span> 即经由当前方格到达它那里 <span class="token punctuation">)</span> 是否更好，用 G 值作参考。更小的 G 值表示这是更好的路径。如果是这样，把它的父亲设置为当前方格，并重新计算它的 G 和 F 值。如果你的 <span class="token function">open</span> list 是按 F 值排序的话，改变后你可能需要重新排序。      d<span class="token punctuation">)</span>停止，当你        ◆ 把终点加入到了 <span class="token function">open</span> list 中，此时路径已经找到了，或者        ◆ 查找终点失败，并且 <span class="token function">open</span> list 是空的，此时没有路径。3.保存路径。从终点开始，每个方格沿着父节点移动直至起点，这就是你的路径。  </code></pre><hr><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p><a href="https://blog.csdn.net/qq_36946274/article/details/81982691" target="_blank" rel="noopener">https://blog.csdn.net/qq_36946274/article/details/81982691</a><br><a href="https://blog.csdn.net/denghecsdn/article/details/78778769" target="_blank" rel="noopener">https://blog.csdn.net/denghecsdn/article/details/78778769</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> A-Star </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL无法启动--Windows环境下如何解决Can&#39;t connect to MySQL server on localhost (10061)</title>
      <link href="/2019/09/24/MySQL%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8-Windows%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3Can-t-connect-to-MySQL-server-on-localhost-10061/"/>
      <url>/2019/09/24/MySQL%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8-Windows%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3Can-t-connect-to-MySQL-server-on-localhost-10061/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><pre class=" language-bash"><code class="language-bash">因为近期做项目需要用到mysql数据库，但用matlab连接数据库时报错：未定义与 <span class="token string">'struct'</span> 类型的输入参数相对应的函数 <span class="token string">'fetch'</span>   </code></pre><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><pre class=" language-bash"><code class="language-bash">查找了网上此类问题的原因，大致如下：安装mysql后使用mysql命令时报错 <span class="token string">"Can't connect to MySQL server on localhost (10061)"</span>，或者用<span class="token string">"net start mysql"</span> 时报服务名无效，一般是因为mysql服务没有启动。   解决方案：    1.修改系统变量  2.重启MySQL     </code></pre><p>修改系统变量具体请参考：<a href="https://blog.csdn.net/wolfking0608/article/details/82784297/" target="_blank" rel="noopener">Solution</a></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><pre class=" language-bash"><code class="language-bash">然鹅，在试过上述修改环境变量后，依然报错，于是，开始怀疑是不是没有启动MySQL服务。打开cmd，在命令行输入<span class="token string">"mysql -u root -p"</span>，提示输入密码。输完密码后直接闪退。  于是换另一种方式重启服务，以下是具体步骤： 在桌面右键单击“我的电脑”--管理--服务和应用程序--服务，在服务名称中找到MySQL57（以MySQL57为例），右键单击将其重新启动即可。好了，大功告成，这次终于成功了。</code></pre><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法介绍</title>
      <link href="/2019/09/04/Markdown%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/09/04/Markdown%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Markdown一些常用命令"><a href="#Markdown一些常用命令" class="headerlink" title="Markdown一些常用命令"></a>Markdown一些常用命令</h2><h3 id="设置标题级别"><a href="#设置标题级别" class="headerlink" title="设置标题级别"></a>设置标题级别</h3><pre class=" language-bash"><code class="language-bash">标题前加几个<span class="token comment" spellcheck="true">#，就代表几级标题</span>一级标题<span class="token comment" spellcheck="true">#标题</span>二级标题<span class="token comment" spellcheck="true">##标题</span></code></pre><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><pre class=" language-bash"><code class="language-bash"><span class="token operator">></span> 亚里士多德说过，人生最终的价值在于觉醒和思考，而不仅仅在于生存。</code></pre><h3 id="写无序列表"><a href="#写无序列表" class="headerlink" title="写无序列表"></a>写无序列表</h3><pre class=" language-bash"><code class="language-bash">- 无序列表</code></pre><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><pre class=" language-bash"><code class="language-bash">数字+英文句号</code></pre><h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><pre class=" language-bash"><code class="language-bash"><span class="token operator">!</span><span class="token punctuation">[</span>中秋<span class="token punctuation">]</span><span class="token punctuation">(</span>http://pic128.huitu.com/res/20190901/571787_20190901124015978020_1.jpg<span class="token punctuation">)</span></code></pre><h3 id="创建超链接"><a href="#创建超链接" class="headerlink" title="创建超链接"></a>创建超链接</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>baidu<span class="token punctuation">]</span><span class="token punctuation">(</span>https://www.baidu.com<span class="token punctuation">)</span></code></pre><h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><pre class=" language-bash"><code class="language-bash">**加粗**</code></pre><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><pre class=" language-bash"><code class="language-bash">*斜体*</code></pre><h3 id="调整字体、字号和颜色"><a href="#调整字体、字号和颜色" class="headerlink" title="调整字体、字号和颜色"></a>调整字体、字号和颜色</h3><pre class=" language-bash"><code class="language-bash"><span class="token string">"&lt;font face="</span>微软雅黑<span class="token string">" color="</span>red<span class="token string">" size="</span>28<span class="token string">">字体、颜色和字号&lt;/font>"</span><span class="token operator">&lt;</span>font face<span class="token operator">=</span><span class="token string">"微软雅黑"</span> color<span class="token operator">=</span><span class="token string">"red"</span> size<span class="token operator">=</span><span class="token string">"28"</span><span class="token operator">></span>字体、颜色和字号<span class="token operator">&lt;</span>/font<span class="token operator">></span></code></pre><h3 id="居中、居左、居右（适用于字体、图片）"><a href="#居中、居左、居右（适用于字体、图片）" class="headerlink" title="居中、居左、居右（适用于字体、图片）"></a>居中、居左、居右（适用于字体、图片）</h3><pre class=" language-bash"><code class="language-bash">居中<span class="token operator">&lt;</span>center<span class="token operator">></span><span class="token operator">&lt;</span>font face<span class="token operator">=</span><span class="token string">"微软雅黑"</span> color<span class="token operator">=</span><span class="token string">"red"</span> size<span class="token operator">=</span><span class="token string">"28"</span><span class="token operator">></span>字体、颜色和字号<span class="token operator">&lt;</span>/font<span class="token operator">></span><span class="token operator">&lt;</span>/center<span class="token operator">></span>  居左<span class="token operator">&lt;</span>p align<span class="token operator">=</span><span class="token string">"left"</span><span class="token operator">></span><span class="token operator">&lt;</span>font face<span class="token operator">=</span><span class="token string">"微软雅黑"</span> color<span class="token operator">=</span><span class="token string">"red"</span> size<span class="token operator">=</span><span class="token string">"28"</span><span class="token operator">></span>字体、颜色和字号<span class="token operator">&lt;</span>/font<span class="token operator">></span><span class="token operator">&lt;</span>/p<span class="token operator">></span></code></pre><hr><center><font faceface="微软雅黑" color="green" size="14">**music**</font></center><center><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&amp;id=481356667&amp;auto=1&amp;height=66"></iframe></center><center><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&amp;id=413812448&amp;auto=0&amp;height=66"></iframe></center><hr><center><font faceface="微软雅黑" color="green" size="12">孔子曾说过:“言必信,行必果”</font></center><hr><center><font faceface="微软雅黑" color="green" size="14">**video**</font></center><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.bilibili.com/video/av23983281" target="_blank" rel="noopener">参考1</a></p><p><a href="https://walesexcitedmei.github.io/2018/08/29/HEXO-hexo-%E4%B8%AD%E6%8F%92%E5%85%A5%E8%A7%86%E9%A2%91%E7%9A%84%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">参考2</a>  </p><p><img src="http://pic128.huitu.com/res/20190901/571787_20190901124015978020_1.jpg" alt="中秋"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win10环境下如何用hexo+git 创建个人博客</title>
      <link href="/2019/09/03/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E6%95%99%E7%A8%8B/"/>
      <url>/2019/09/03/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第一章-如何部署环境？"><a href="#第一章-如何部署环境？" class="headerlink" title="第一章  如何部署环境？"></a>第一章  如何部署环境？</h2><pre><code>1.首先下载node.js，下载地址：https://nodejs.org，安装完成后会有包管理器npm（搭建hexo博客框架所必需）。2.安装淘宝的npm的镜像源，在cmd窗口中输入：npm install -g cnpm --registry=https://registry.npm.taobao.org，Enter等待安装完成。（install -g 全局安装）3.利用2中安装的cnpm安装hexo框架，在cmd窗口中输入：cnpm install -g hexo-cli，Enter等待安装完成。至此，hexo安装完成。</code></pre><hr><h2 id="第二章-如何初始化博客？"><a href="#第二章-如何初始化博客？" class="headerlink" title="第二章  如何初始化博客？"></a>第二章  如何初始化博客？</h2><pre><code>1.创建博客存放的文件夹，在cmd窗口中输入：mkdir blog，可以在当前路径下找到blog文件夹（命令：dir），定位到blog文件夹 cd blog，初始化博客hexo init（此步骤之前本地需安装git），等待初始化完成。2.启动本地博客hexo s，浏览器输入：localhost:4000，即可访问。</code></pre><hr><h2 id="第三章-如何写博客？"><a href="#第三章-如何写博客？" class="headerlink" title="第三章  如何写博客？"></a>第三章  如何写博客？</h2><pre><code>1.新建内容hexo n "我的第一篇博客文章"，定位到文章所在文件夹cd source/_posts，查看文件夹下文件目录dir，可用vim/notepad打开vim/notepad 我的第一篇博客文章.md，修改之（makedown格式语法）。2.清理hexo clean，生成hexo g，重启hexo s</code></pre><hr><h2 id="第四章-如何将hexo发布到github上？"><a href="#第四章-如何将hexo发布到github上？" class="headerlink" title="第四章  如何将hexo发布到github上？"></a>第四章  如何将hexo发布到github上？</h2><pre><code>1.Create a new repository in github，repository's name must be consistent with your  person  github's name.    e.g. my github's name is hlgao666, then repository's name must be hlgao666.github.io.2.安装发布插件，cnpm install --save hexo-deployer-git3.修改插件的_config.yml文件。新增：   1）在delpoyment中的type: git；   2）repo:  https://github.com/hlgao666/hlgao666.github.io.git（https的SSH地址）；   3）branch: master4.部署到远端hexo d，此时可直接访问仓库名hlgao666.github.io.</code></pre><hr><h2 id="第五章-如何更换博客主题？"><a href="#第五章-如何更换博客主题？" class="headerlink" title="第五章 如何更换博客主题？"></a>第五章 如何更换博客主题？</h2><pre><code>1.直接克隆：git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia，https://github.com/litten/hexo-theme-yilia.git为源主题地址，存放在blog的themes/yilia下。2.修改插件的_config.yml文件，修改theme为yilia3.hexo clean, hexo g, hexo s, hexo d</code></pre><hr><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><pre><code>cd ../..         后退2层文件夹dir        查看当前文件夹下文件目录     mkdir blog     新建blog文件夹hexo clean    清除hexo g        生成，generatehexo s        启动，starthexo n        新建，newhexo d        发布到远端，deployhexo g -d    生成并发布</code></pre><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://github.com/hlgao666" target="_blank" rel="noopener">https://github.com/hlgao666</a><br><a href="https://www.bilibili.com/video/av44544186" target="_blank" rel="noopener">https://www.bilibili.com/video/av44544186</a><br><a href="https://www.codesheep.cn" target="_blank" rel="noopener">https://www.codesheep.cn</a><br><a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/#toc-heading-24" target="_blank" rel="noopener">https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/#toc-heading-24</a></p><hr><h3 id="jump-to-My-Github"><a href="#jump-to-My-Github" class="headerlink" title="jump to My Github"></a><center><a href="https://github.com/hlgao666" target="_blank" rel="noopener">jump to My Github</a></center></h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo+git 个人博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/09/03/hello-world/"/>
      <url>/2019/09/03/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><h2 id="More-info-Deployment"><a href="#More-info-Deployment" class="headerlink" title="More info: Deployment"></a>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></h2><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">https://github.com/blinkfox/hexo-theme-matery</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
